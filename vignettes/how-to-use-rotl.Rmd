---
title: "How to use rotl?"
author: "FranÃ§ois Michonneau"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

`rotl` provides an interface to the Open Tree of Life (OTL) API and allows users
to query the API, retrieve parts of the Tree of Life and integrate these parts
with other R packages.

The OTL API provides services to access:

* the **Tree of Life** a.k.a. TOL (the synthetic tree): a single draft tree that is
a combination of **the OTL taxonomy** and the **source trees** (studies)
* the **Graph of Life** a.k.a. GOL: the neo4j graph database used to store and
build the synthetic tree. It includes additional information (more nodes and
edges) that is not in the TOL.
* the **Taxonomic name resolution services** a.k.a. TNRS: the methods for
  resolving taxonomic names to the internal identifiers used by the TOL and the
  GOL (the `ott ids`).
* the **Taxonomy** a.k.a. OTT (for Open Tree Taxonomy): which represents the
  synthesis of the different taxonomies used as a backbone of the TOL when no
  studies are available.
* the **Studies** containing the source trees used to build the TOL, and
extracted from the scientific literature.

In `rotl`, each of these services correspond to functions with different
prefixes:

| Service       | `rotl` prefix |
|---------------|---------------|
| Tree of Life  | `tol_`        |
| Graph of Life | `gol_`        |
| TNRS          | `tnrs_`       |
| Studies       | `studies_`    |

`rotl` also provides a few other functions that can be used to extract relevant
information from the objects returned by these functions.


## Demonstration of a basic workflow

The most common use for `rotl` is probably to start from a list of species and
get the relevant parts of the tree for these species. This is a two step
process:

1. the species names need to be matched to their `ott_id` (the Open Tree
Taxonomy identifiers) using the Taxonomic name resolution services (TNRS)
1. these `ott_id` will then be used to retrieve the relevant parts of the Tree
of Life.

### Step 1: Matching taxonomy to the `ott_id`

Let's start by doing a search on a diverse group of taxa: a tree frog (genus
_Hyla_), a fish (genus _Salmo_), a sea urchin (genus _Diadema_), and a nautilus
(genus _Nautilus_).

```{r}
library(rotl)
taxa <- c("Hyla", "Salmo", "Diadema", "Nautilus")
resolved_names <- tnrs_match_names(taxa)
```

It's always a good idea to check that the resolved names match what you
intended:

`r knitr::kable(resolved_names)`

The column `unique_name` sometimes indicates the higher taxonomic level
associated with the name. Here we queried on genera names, so the API indicates
the family names associated with some the genera. The column `number_matches`
indicates the number of `ott_id` that corresponds to a given name. In our
example, our search on _Diadema_ returns 4 matches, and the one returned by
default is a fungus and not the sea urchin that we want for our query.

The argument `context_name` allows you to limit the taxonomic scope of your
search. In this case, if we limit our search to animals, the genus _Diadema_ now
matches the sea urchin (notice the family is Diadematidae):

```{r}
resolved_names <- tnrs_match_names(taxa, context_name = "Animals")
```

`r knitr::kable(resolved_names)`

If you are trying to build a tree with deeply divergent taxa that the argument
`context_name` cannot fix, see "How to change the ott ids assigned to my taxa?"
in the FAQ below.


### Step 2: Getting the tree corresponding to our taxa

Now that we have the correct `ott_id` for our taxa, we can ask for the tree
using the `tol_induced_subtree()` function. By default, the object returned by
`tol_induced_subtree` is a phylo object (from the
[ape](http://cran.r-project.org/package=ape) package), so we can plot it
directly.

```{r, fig.width=7, fig.height=4}
my_tree <- tol_induced_subtree(ott_ids = resolved_names$ott_id)
plot(my_tree, no.margin=TRUE)
```


## FAQ

### How to change the ott ids assigned to my taxa?

If you realize that `tnrs_match_names` assigns the incorrect taxonomic group to
your name (e.g., because of synonymy) and changing the `context_name` does not
help, you can use the function `inspect`. This function takes the object
resulting from `tnrs_match_names()`, and either the row number, the taxon name
(you used in your search in lowercase), or the `ott_id` returned by the initial
query.

To illustrate this, let's re-use the previous query but by adding a tree to our
list of taxa (Oak tree, genus _Acer_), such that restricting our search to
animals doesn't work.

```{r}
taxa <- c("Hyla", "Salmo", "Diadema", "Nautilus", "Acer")
resolved_names <- tnrs_match_names(taxa)
resolved_names
inspect(resolved_names, taxon_name = "diadema")
```

In our case, we want the second row in this data frame to replace the
information that initially matched for _Diadema_. We can now use the `update()`
function, to change to the correct taxa (the sea urchin not the fungus):

```{r}
resolved_names <- update(resolved_names, taxon_name = "diadema",
                         new_row_number = 2)

## we could also have used the ott_id to replace this taxon:
## resolved_names <- update(resolved_names, taxon_name = "diadema",
##                          new_ott_id = 631176)
```

And now our `resolved_names` data frame includes the taxon we want:

`r knitr::kable(resolved_names)`

### How do I know that the taxa I'm asking for is the correct one?

The function `taxonomy_taxon()` takes `ott_ids` as arguments and returns
taxonomic information about the taxa. This output can be passed to some helpers
functions to extract the relevant information. Let's illustrate this with our
_Diadema_ example

```{r}
diadema_info <- taxonomy_taxon(631176)
tax_rank(diadema_info)
synonyms(diadema_info)
ott_taxon_name(diadema_info)
```

In some cases, it might also be useful to investigate the taxonomic tree
descending from an `ott_id` to check that it's the correct taxon and to
determine the species included in the Open Tree Taxonomy:

```{r}
diadema_tax_tree <- taxonomy_subtree(631176)
diadema_tax_tree
```

By default, this function return all taxa (including self, and internal)
descending from this `ott_id` but it also possible to return `phylo` object.

### How do I get the tree for a particular taxonomic group?

If you are looking to get the tree for a particular taxonomic group, you need to
first identify it by its node id or ott id, and then use the `tol_subtree()`
function:

```{r, fig.width=7, fig.height=4}
mono_id <- tnrs_match_names("Monotremes")
mono_tree <- tol_subtree(ott_id = mono_id$ott_id[1])
plot(mono_tree)
```


### How do I find trees from studies focused on my favourite taxa?

The function `studies_find_trees()` allows the user to search for studies
matching a specific criteria. The function `studies_properties()` returns the
list of properties that can be used in the search.

```{r}
furry_studies <- studies_find_studies(property="ot:focalCladeOTTTaxonName", value="Mammalia")
furry_ids <- unlist(furry_studies$matched_studies)
```

Now that we know the `study_id`, we can ask for the meta data information
associated with this study:

```{r}
furry_meta <- get_study_meta("pg_2550")
knitr::kable(get_publication(furry_meta))     ## The citation for the source of the study
get_tree_ids(furry_meta)        ## This study has 10 trees associated with it
candidate_for_synth(furry_meta) ## None of these trees are yet included in the OTL
```

Using `get_study("pg_2550")` would returns a `multiPhylo` object (default) with
all the trees associated with this particular study, while
`get_study_tree("pg_2550", "tree5513")` would return one of these trees.

##Combining data from OToL and other sources. 

One of the major goals of `rotl` is to help users combine data from other
sources with the phylogenetic trees in OToL. As an example, let's see if we can
combine data from [`fishbase`](http://www.fishbase.org/), using the ROpenSci
package [`rfishbase`](https://github.com/ropensci/rfishbase). 


### Find a tree for your focal taxon

Since we are using fishbase in our example, let's focus on one of the most
diverse fish clades, the cyprinids (carps, true minnows and their kin). We could 
use `tol_induced_subtree` to get the synthetic tree for this group, or
`studies_find_studies` to see if there are any published papers available for
the group. Let's start with the second approach:

```{r, find_study}
cyp_studies <- studies_find_studies("ot:focalCladeOTTTaxonName", value="Cyprinidae")
cyp_studies
```

So there is at least one study on the cyprinids, we can get some more
information on it using `get_study_meta`:

```{r, meta}
meta <- get_study_meta("pg_1909")
meta
```

`rotl` provides some helper functions to extract elements from this metadata, so
we can the title and DOI for this study:

```{r, pub}
get_publication(meta)
```

OK, this look like a good study. Let's get the trees from this study and check
them out:

```{r, get_study_tr}
get_tree_ids(meta)
tr <- get_study_tree(study="pg_1909", tree_id=get_tree_ids(meta))
tr
```
### Now find some data to attach to the tips in the tree

The `rfishbase` package provides us with a local version of the fishbase
database, and some tools to extract information from it. Let's load the data,
and check it out

```{r, fishbase_intro}
library(rfishbase)
data(fishbase)
typeof(fish.data)
length(fish.data)
```
So, `fish.data` is a big list. Each element of the list has data from one
species, with each of the following sub-elements:

```{r, data}
names(fish.data[[1]])
```

We want to match up data in this list to the tips in our tree, unfortunately the
names are formatted slightly differently:

```{r, compare_labels}
tr$tip.label[14]
fish.data[[23210]]$ScientificName
```

So before we can match the tip labels to the data in the list we have to
substitute the underscores in the tip labels for spaces. We can then extract the
`SceintificName` from each `fishbase` entry to see if they match something in
our tree:

```{r, fishy_data}
tr$tip.label <- sub("_", " ", tr$tip.label)
fishbase_in_tree <- fish.data[sapply(fish.data, "[[", "ScientificName") %in% tr$tip.label]
length(fishbase_in_tree)
```

###Red Fish Blue Fish

OK, so we have a tree and we have data for 142 of the species in that tree.
Let's drop the tips representing fish we have no data on:

```{r, drop}
to_drop <- tr$tip.label[!tr$tip.label %in% sapply(fishbase_in_tree, "[[", "ScientificName")]
subtree <- drop.tip(tr, to_drop, rooted=TRUE)
subtree
```
We now have a tree with 142 tips, and a datset with 142 entries, but each one of
those datasets is in a different order. Let's line them up by extracting the
names from the fishbase data and matching them against the tree:


```{r, fbsorted}
fb_names <- sapply(fishbase_in_tree, "[[", "ScientificName")
fishbase_in_tree_sorted <- fishbase_in_tree[match(fb_names , subtree$tip.label)]
```

fascinating theory should we test? Let's follow up [Suess (1960)](https://en.wikipedia.org/wiki/One_Fish_Two_Fish_Red_Fish_Blue_Fish) and explore the distribution of coloration in 
these fish. Specifically, we can use the `rfishbase` function `which_fish` to
find red fish and blue fish in our phylogeny:

```{r, redfishbluefish}
bluefish<- which_fish("grey|green|blue", using="diagnostic", fish.data=fishbase_in_tree_sorted)
redfish <- which_fish("red|orange", using="diagnostic", fish.data=fishbase_in_tree_sorted)
```


```{r, plot,  fig.width=7, fig.height=4}
cols <- rep("#FFFFFF00", length(subtree$tip.label))
cols[redfish] <- "red"
cols[bluefish] <- "blue"
plot(subtree, show.tip.label=F)
tiplabels(pch=16, col=cols, adj=2)
```
